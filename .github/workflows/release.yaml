name: Release

on:
  push:
    branches:
      - main
      - release/v*

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  create-changeset-pull-request:
    name: Create Changeset PR
    runs-on: ubuntu-latest
    steps:
      # Checkout the Branch which was pushed ('main' or 'release/v*')
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect wanted Node & pnpm version
        id: env-versions
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'))

            return {
              node: pkg.engines.node,
              pnpm: pkg.engines.pnpm
            }

      - name: Setup Node & pnpm
        uses: ./.github/actions/setup-pnpm
        with:
          node_version: ${{ fromJSON(steps.env-versions.outputs.result).node }}
          pnpm_version: ${{ fromJSON(steps.env-versions.outputs.result).pnpm }}

      - name: Install & build Dependencies
        run: pnpm bootstrap

      # This will fail the build if something in the publish setup is not correct
      # before changeset magic is starting to run
      - name: Test publish step
        run: pnpm -r publish --dry-run

      # The changeset action will behave differently based on whether there are
      # new changesets on the configured branch:
      #
      #  - new changesets: create a preview PR with the new version bumps and changelogs
      #  - no new changesets (the preview PR got merged into current branch): publish packages
      - name: Changeset Magic
        id: changesets
        uses: changesets/action@v1
        env:
          GITHUB_TOKEN: ${{ secrets.SWISSPOSTDEVS_ACCESS_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        with:
          title: 'chore(changesets): ðŸ¦‹ðŸ“¦ publish packages (${{ github.ref_name }})'
          commit: 'chore(changesets): publish packages'
          publish: pnpm changeset:publish
          version: pnpm changeset:version

  collect-release-data:
    name: Detect Major Release
    runs-on: ubuntu-latest
    outputs:
      release-data: ${{ steps.release-data.outputs.result }}
      release-branch-exists: ${{ steps.release_branch.outputs.release-branch-exists }}
    steps:
      # Checkout the Branch which has been pushed ('main' or 'release/v*')
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect wanted Node & pnpm version
        id: env-versions
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'))

            return {
              node: pkg.engines.node,
              pnpm: pkg.engines.pnpm
            }

      - name: Setup Node & pnpm
        uses: ./.github/actions/setup-pnpm
        with:
          node_version: ${{ fromJSON(steps.env-versions.outputs.result).node }}
          pnpm_version: ${{ fromJSON(steps.env-versions.outputs.result).pnpm }}

      - name: Install Dependencies
        run: pnpm i

      # Create Status Files
      - name: Create Status Files
        run: |
          pnpm m ls --depth=0 --json > monorepo.json
          pnpm changeset status --output=changesets.json

      # Read the status Files and collect release data on the @swisspost/design-system-styles package
      - name: Collect Release Data
        id: release-data
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const monorepo = JSON.parse(fs.readFileSync('monorepo.json', 'utf8'))
            const styles = JSON.parse(fs.readFileSync('./packages/styles/package.json', 'utf8'))
            const changesets = JSON.parse(fs.readFileSync('changesets.json', 'utf8'))

            console.log(changesets)
            if (changesets.releases.length === 0) {
              return null
            }

            const release = changesets.releases.find(changeset => changeset.name === '@swisspost/design-system-styles')
            const oldMajor = release.oldVersion.split('.')[0];
            const newMajor = release.newVersion.split('.')[0];
            const dependencies = monorepo
              .filter(pkg => pkg.private === false && pkg.version !== undefined)
              .reduce((packages, pkg) => ({ ...packages, [pkg.name]: pkg.version }), { ...(styles.peerDependencies ?? {}) })

            return {
              isMajor: release.type === 'major',
              old: {
                version: release.oldVersion,
                major: oldMajor,
                siteUrl: `spds-test-v${oldMajor}`
              },
              new: {
                version: release.newVersion,
                major: newMajor
              },
              branchName: `release/v${oldMajor}`,
              dependencies
            }

      # Check if the release Branch already exists
      # Output the branchName for usage in following Jobs (returns empty string if branch does not exist)
      - name: Check if Release Branch exists
        id: release-branch-exists
        run: echo "release-branch-exists=$(git rev-parse --verify --quiet ${{ fromJSON(steps.release-data.outputs.result).branchName }})" >> $GITHUB_OUTPUT

  # Only run this Job if:
  # - Changeset PR has been created
  # - Release Data exists
  update-changeset-branch:
    name: Update Changeset Branch
    runs-on: ubuntu-latest
    needs: [create-changeset-pull-request, collect-release-data]
    if: ${{ fromJSON(needs.collect-release-data.outputs.release-data) }} != 'null'
    steps:
      # Checkout the changeset Branch
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: 'changeset-release/${{ github.ref_name }}'

      - name: Detect wanted Node & pnpm version
        id: env-versions
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'))

            return {
              node: pkg.engines.node,
              pnpm: pkg.engines.pnpm
            }

      - name: Setup Node & pnpm
        uses: ./.github/actions/setup-pnpm
        with:
          node_version: ${{ fromJSON(steps.env-versions.outputs.result).node }}
          pnpm_version: ${{ fromJSON(steps.env-versions.outputs.result).pnpm }}
          use_cache: false

      - name: Output Status Files
        run: pnpm m ls --depth=0 --json > monorepo.json

      # Only run this Step if a major release was detected and the release Branch does not already exist
      - name: Update or create Documentation _redirects
        id: update-redirects
        if: ${{ fromJSON(needs.collect-release-data.outputs.release-data).isMajor }} == 'true' && needs.collect-release-data.outputs.release-branch-exists == ''
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const release = ${{ needs.collect-release-data.outputs.release-data }}

            const redirectsPath = './packages/documentation/public/_redirects'
            let redirects = ''

            if (fs.existsSync(redirectsPath)) {
               redirects = fs.readFileSync(redirectsPath, 'utf8')
            } else {
              redirects = '# Redirects from what the browser requests to what we serve\n'
            }

            redirects += `/v${release.old.major}   https://${release.old.siteUrl}.netlify.app`
            fs.writeFileSync(redirectsPath, redirects + '\n')

            return true

      - name: Update Documentation versions.json
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const release = ${{ needs.collect-release-data.outputs.release-data }}

            const versionsPath = './packages/documentation/public/assets/versions.json'
            const versions = JSON.parse(fs.readFileSync(versionsPath, 'utf8'))
            const monorepo = JSON.parse(fs.readFileSync('monorepo.json', 'utf8'))
            const styles = JSON.parse(fs.readFileSync('./packages/styles/package.json', 'utf8'))

            const currentVersion = versions.find(version => version.version.startsWith(release.old.major))
            currentVersion.version = release.new.version
            currentVersion.dependencies = release.dependencies

            if (release.isMajor) {
              currentVersion.version = release.old.version
              currentVersion.url = `https://${release.old.siteUrl}.netlify.app`

              const dependencies = monorepo
                .filter(pkg => pkg.private === false && pkg.version !== undefined)
                .reduce((packages, pkg) => ({ ...packages, [pkg.name]: pkg.version }), { ...(styles.peerDependencies ?? {}) })
              versions.unshift({
                title: `Version ${release.new.major}`,
                version: release.new.version,
                description: 'Pattern documentation, code snippets and implementation guidelines for the Design System Styles.',
                url: 'https://design-system.post.ch',
                dependencies
              })
            }

            fs.writeFileSync(versionsPath, JSON.stringify(versions, null, 2) + '\n')

      - name: Remove Status Files
        run: rm -f monorepo.json

      - name: Commit Changes and Push Branch
        uses: EndBug/add-and-commit@v9
        with:
          message: 'chore(changesets): update version specific files'
          push: true

  # Only run this Job if:
  # - Workflow runs on the 'main' Branch
  # - Release Data exists
  # - A Major Release was detected
  # - The release Branch does not already exist
  create-release-branch:
    name: Setup Previous Release Branch
    runs-on: ubuntu-latest
    needs: collect-release-data
    if: ${{ github.ref_name }} == 'main' && ${{ fromJSON(needs.collect-release-data.outputs.release-data) }} != 'null' && ${{ fromJSON(needs.collect-release-data.outputs.release-data).isMajor }} == 'true' && needs.collect-release-data.outputs.release-branch-exists == ''
    steps:
      # Checkout the commit with the release.old.version tag (e.g. @swisspost/design-system-styles@5.3.2)
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: '@swisspost/design-system-styles@${{ fromJSON(needs.collect-release-data.outputs.release-data).old.version }}'

      - name: Detect wanted Node & pnpm version
        id: env-versions
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'))

            return {
              node: pkg.engines.node,
              pnpm: pkg.engines.pnpm
            }

      - name: Setup Node & pnpm
        uses: ./.github/actions/setup-pnpm
        with:
          node_version: ${{ fromJSON(steps.env-versions.outputs.result).node }}
          pnpm_version: ${{ fromJSON(steps.env-versions.outputs.result).pnpm }}

      - name: Remove Documentation versions.json
        run: rm -f ./packages/documentation/public/assets/versions.json

      # Install dependencies & Build all packages
      - name: Install Dependencies & Build Packages
        run: pnpm bootstrap

      # Install Netlify CLI globally
      - name: Install Netlify CLI
        run: pnpm i -g netlify-cli

      # Create a new Netlify Site with a version specific subdomain
      # Deploy the output of @swisspost/design-system-documentation to the before created Netlify Site
      - name: Create & Deploy Netlify Site
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
        run: |
          netlify sites:create --filter @swisspost/design-system-documentation --account-slug oliverschuerch --name ${{ fromJSON(needs.collect-release-data.outputs.release-data).old.siteUrl }} --manual
          netlify deploy --filter @swisspost/design-system-documentation --build false --dir packages/documentation/storybook-static --prod

      - name: Update Changeset config.json
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const release = ${{ needs.collect-release-data.outputs.release-data }}

            const changesetConfigPath = './.changeset/config.json'
            const changesetConfig = JSON.parse(fs.readFileSync(changesetConfigPath, 'utf8'))
            fs.writeFileSync(changesetConfigPath, JSON.stringify({
              ...changesetConfig,
              baseBranch: release.branchName
            }, null, 2) + '\n')

      - name: Update Documentation netlify.config.json
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const release = ${{ needs.collect-release-data.outputs.release-data }}

            const netlifyState = JSON.parse(fs.readFileSync('./packages/documentation/.netlify/state.json', 'utf8'))
            fs.writeFileSync('./packages/documentation/netlify.config.json', JSON.stringify({
              ...netlifyState,
              siteUrl: `https://${release.old.siteUrl}.netlify.app`
            }, null, 2) + '\n')

      # Commit the changes to a new release/v* branch
      - name: Commit Changes and Push Release Branch
        uses: EndBug/add-and-commit@v9
        with:
          new_branch: ${{ fromJSON(needs.collect-release-data.outputs.release-data).branchName }}
          message: 'chore(setup): create "${{ fromJSON(needs.collect-release-data.outputs.release-data).branchName }}" branch'
          push: true
