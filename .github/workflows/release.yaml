name: Release

on:
  push:
    branches:
      - main
      - release/v*

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  changeset-magic:
    name: Changeset Magic
    runs-on: ubuntu-latest
    steps:
      # Checkout the Branch which was pushed ('main' or 'release/v*')
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect wanted Node & pnpm version
        id: env-versions
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'))

            return {
              node: pkg.engines.node,
              pnpm: pkg.engines.pnpm
            }

      - name: Setup Node & pnpm
        uses: ./.github/actions/setup-pnpm
        with:
          node_version: ${{ fromJSON(steps.env-versions.outputs.result).node }}
          pnpm_version: ${{ fromJSON(steps.env-versions.outputs.result).pnpm }}

      - name: Install & build Dependencies
        run: pnpm bootstrap

      # This will fail the build if something in the publish setup is not correct
      # before changeset magic is starting to run
      - name: Test publish step
        run: pnpm -r publish --dry-run

      # The changeset action will behave differently based on whether there are
      # new changesets on the configured branch:
      #
      #  - new changesets: create a preview PR with the new version bumps and changelogs
      #  - no new changesets (the preview PR got merged into current branch): publish packages
      - name: Changeset Magic
        id: changesets
        uses: changesets/action@v1
        env:
          GITHUB_TOKEN: ${{ secrets.SWISSPOSTDEVS_ACCESS_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        with:
          title: 'chore(changesets): ðŸ¦‹ðŸ“¦ publish packages (${{ github.ref_name }})'
          commit: 'chore(changesets): publish packages'
          publish: pnpm changeset:publish
          version: pnpm changeset:version

      - name: Create Summary
        id: summary
        uses: actions/github-script@v7
        env:
          PUBLISHED: ${{ steps.changesets.outputs.published }}
          PUBLISHED_PACKAGES: ${{ steps.changesets.outputs.publishedPackages }}
        with:
          script: |
            const publishedPackages = JSON.parse(process.env.PUBLISHED_PACKAGES)

            return `# Changesets
            - Changesets published: <code>${process.env.PUBLISHED}</code>
            - Published Packages:
            <pre>${JSON.stringify(publishedPackages, null, 2)}</pre>
            `

      - name: Output Summary
        run: echo -e ${{ steps.summary.outputs.result }} >> $GITHUB_STEP_SUMMARY

  # Only run this Job if:
  # - Workflow runs on the 'main' Branch
  collect-release-data:
    name: Collect Release Data
    runs-on: ubuntu-latest
    needs: changeset-magic
    if: github.ref_name == 'main'
    outputs:
      release-data: ${{ steps.release-data.outputs.result }}
      release-branch-exists: ${{ steps.release-branch-exists.outputs.exists }}
      release-changeset-branch-exists: ${{ steps.release-changeset-branch-exists.outputs.exists }}
    steps:
      # Checkout the Branch which has been pushed ('main' or 'release/v*')
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect wanted Node & pnpm version
        id: env-versions
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'))

            return {
              node: pkg.engines.node,
              pnpm: pkg.engines.pnpm
            }

      - name: Setup Node & pnpm
        uses: ./.github/actions/setup-pnpm
        with:
          node_version: ${{ fromJSON(steps.env-versions.outputs.result).node }}
          pnpm_version: ${{ fromJSON(steps.env-versions.outputs.result).pnpm }}

      - name: Install Dependencies
        run: pnpm i

      # Create Status Files
      - name: Create Status Files
        run: |
          pnpm m ls --depth=0 --json > monorepo.json
          pnpm changeset status --output=changesets.json

      # Read the status Files and collect release data on the @swisspost/design-system-styles package
      - name: Collect Release Data
        id: release-data
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const monorepo = JSON.parse(fs.readFileSync('monorepo.json', 'utf8'))
            const styles = JSON.parse(fs.readFileSync('./packages/styles/package.json', 'utf8'))
            const changesets = JSON.parse(fs.readFileSync('changesets.json', 'utf8'))
            const release = changesets.releases.find(r => r.name === '@swisspost/design-system-styles')

            if (!release) return null

            const oldMajor = release.oldVersion.split('.')[0];
            const newMajor = release.newVersion.split('.')[0];
            const dependencies = monorepo
              .filter(pkg => pkg.private === false && pkg.version !== undefined)
              .reduce((packages, pkg) => ({ ...packages, [pkg.name]: pkg.version }), { ...(styles.peerDependencies ?? {}) })

            return {
              isMajor: release.type === 'major',
              old: {
                version: release.oldVersion,
                major: oldMajor,
                siteUrl: `spds-test-v${oldMajor}`
              },
              new: {
                version: release.newVersion,
                major: newMajor,
                siteUrl: 'design-system'
              },
              branchName: `release/v${oldMajor}`,
              dependencies
            }

      # Check if the "release/v*" Branch already exists
      - name: Check if Release Branch exists
        id: release-branch-exists
        uses: GuillaumeFalourd/branch-exists@v1
        with:
          branch: ${{ fromJSON(steps.release-data.outputs.result).branchName }}

      # Check if the "changeset-release/*" Branch already exists
      - name: Check if Release-Changeset Branch exists
        id: release-changeset-branch-exists
        uses: GuillaumeFalourd/branch-exists@v1
        with:
          branch: changeset-release/${{ github.ref_name }}

      - name: Create Summary
        id: summary
        uses: actions/github-script@v7
        env:
          REF_NAME: ${{ github.ref_name }}
          RELEASE_DATA: ${{ steps.release-data.outputs.result }}
          RELEASE_BRANCH_EXISTS: ${{ steps.release-branch-exists.outputs.exists }}
          RELEASE_CHANGESET_BRANCH_EXISTS: ${{ steps.release-changeset-branch-exists.outputs.exists }}
        with:
          script: |
            const release = JSON.parse(process.env.RELEASE_DATA)
            const releaseBranch = release.branchName ? `(<code>${release.branchName}</code>)` : ''

            return `# Release Data
            - Collecting Data: ${process.env.RELEASE_DATA === null ? ':warning: WARNING: No Release Data found!' : ':rocket: SUCCESS!'}
            <pre>${JSON.stringify(release, null, 2)}</pre>
            - The release/v* Branch ${releaseBranch} exists already: <code>${process.env.RELEASE_BRANCH_EXISTS}</code>
            - The Release-Changeset Branch (<code>changeset-release/${process.env.REF_NAME}</code>) exists already: <code>${process.env.RELEASE_CHANGESET_BRANCH_EXISTS}</code>
            `

      - name: Output Summary
        run: echo -e ${{ steps.summary.outputs.result }} >> $GITHUB_STEP_SUMMARY

  # Only run this Job if:
  # - Workflow runs on the 'main' Branch
  # - Release-Changeset Branch exists
  # - Release Data exists
  update-changeset-branch:
    name: Update changeset-release/{main,release/v*} Branch
    runs-on: ubuntu-latest
    needs: collect-release-data
    if: github.ref_name == 'main' && needs.collect-release-data.outputs.release-changeset-branch-exists == 'true' && fromJSON(needs.collect-release-data.outputs.release-data) != null
    steps:
      # Checkout the changeset Branch
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: changeset-release/${{ github.ref_name }}

      - name: Detect wanted Node & pnpm version
        id: env-versions
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'))

            return {
              node: pkg.engines.node,
              pnpm: pkg.engines.pnpm
            }

      - name: Setup Node & pnpm
        uses: ./.github/actions/setup-pnpm
        with:
          node_version: ${{ fromJSON(steps.env-versions.outputs.result).node }}
          pnpm_version: ${{ fromJSON(steps.env-versions.outputs.result).pnpm }}
          use_cache: false

      - name: Output Status Files
        run: pnpm m ls --depth=0 --json > monorepo.json

      # Only run this Step if the Release Branch does not already exist and a major release was detected
      - name: Update or create Documentation _redirects
        id: update-redirects
        if: needs.collect-release-data.outputs.release-branch-exists == 'false' && fromJSON(needs.collect-release-data.outputs.release-data).isMajor == true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const release = ${{ needs.collect-release-data.outputs.release-data }}

            const redirectsPath = './packages/documentation/public/_redirects'
            let redirects = ''

            if (fs.existsSync(redirectsPath)) {
               redirects = fs.readFileSync(redirectsPath, 'utf8')
            } else {
              redirects = '# Redirects from what the browser requests to what we serve\n'
            }

            redirects += `/v${release.old.major}   https://${release.old.siteUrl}.netlify.app`
            fs.writeFileSync(redirectsPath, redirects + '\n')

            return true

      - name: Update Documentation versions.json
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const release = ${{ needs.collect-release-data.outputs.release-data }}

            const versionsPath = './packages/documentation/public/assets/versions.json'
            const versions = JSON.parse(fs.readFileSync(versionsPath, 'utf8'))
            const monorepo = JSON.parse(fs.readFileSync('monorepo.json', 'utf8'))
            const styles = JSON.parse(fs.readFileSync('./packages/styles/package.json', 'utf8'))

            const currentVersion = versions.find(version => version.version.startsWith(release.old.major))
            currentVersion.version = release.new.version
            currentVersion.dependencies = release.dependencies

            if (release.isMajor) {
              currentVersion.version = release.old.version
              currentVersion.url = `https://${release.old.siteUrl}.netlify.app`

              const dependencies = monorepo
                .filter(pkg => pkg.private === false && pkg.version !== undefined)
                .reduce((packages, pkg) => ({ ...packages, [pkg.name]: pkg.version }), { ...(styles.peerDependencies ?? {}) })
              versions.unshift({
                title: `Version ${release.new.major}`,
                version: release.new.version,
                description: 'Pattern documentation, code snippets and implementation guidelines for the Design System Styles.',
                url: 'https://${release.new.siteUrl}.post.ch',
                dependencies
              })
            }

            fs.writeFileSync(versionsPath, JSON.stringify(versions, null, 2) + '\n')

      - name: Remove Status Files
        run: rm -f monorepo.json

      - name: Commit Changes and Push Branch
        uses: EndBug/add-and-commit@v9
        with:
          message: 'chore(changesets): update release specific files'
          push: true

      - name: Create Summary
        id: summary
        uses: actions/github-script@v7
        env:
          REF_NAME: ${{ github.ref_name }}
          RELEASE_DATA: ${{ needs.collect-release-data.outputs.release-data }}
          RELEASE_BRANCH_EXISTS: ${{ needs.collect-release-data.outputs.release-branch-exists }}
        with:
          script: |
            const release = JSON.parse(process.env.RELEASE_DATA)

            return `# Changeset Branch
            The Release-Changeset Branch <code>changeset-release/${process.env.REF_NAME}</code> has been created by the Changeset Action.
            In addition to that, the following updates have been made to this Branch:
            ${release.isMajor && process.env.RELEASE_BRANCH_EXISTS === 'false' ? `- Netlify <code>_redirects</code> File has been created on to the <code>changeset-release/${process.env.REF_NAME}</code> Branch.` : ''}
            - The Netlify <code>versions.json</code> File has been updated on to the <code>changeset-release/${process.env.REF_NAME}</code> Branch.
            `

      - name: Output Summary
        run: echo -e ${{ steps.summary.outputs.result }} >> $GITHUB_STEP_SUMMARY

  # Only run this Job if:
  # - Workflow runs on the 'main' Branch
  # - Release Branch does not already exist
  # - Release Data exists
  # - A Major Release was detected
  create-release-branch:
    name: Create release/v* Branch
    runs-on: ubuntu-latest
    needs: collect-release-data
    if: github.ref_name == 'main' && needs.collect-release-data.outputs.release-branch-exists == 'false' && fromJSON(needs.collect-release-data.outputs.release-data) != null && fromJSON(needs.collect-release-data.outputs.release-data).isMajor == true
    steps:
      # Checkout the commit with the release.old.version tag (e.g. @swisspost/design-system-styles@5.3.2)
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: '@swisspost/design-system-styles@${{ fromJSON(needs.collect-release-data.outputs.release-data).old.version }}'

      - name: Detect wanted Node & pnpm version
        id: env-versions
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'))

            return {
              node: pkg.engines.node,
              pnpm: pkg.engines.pnpm
            }

      - name: Setup Node & pnpm
        uses: ./.github/actions/setup-pnpm
        with:
          node_version: ${{ fromJSON(steps.env-versions.outputs.result).node }}
          pnpm_version: ${{ fromJSON(steps.env-versions.outputs.result).pnpm }}

      - name: Remove Documentation versions.json
        run: rm -f ./packages/documentation/public/assets/versions.json

      # Install dependencies & Build all packages
      - name: Install Dependencies & Build Packages
        run: pnpm bootstrap

      # Install Netlify CLI globally
      - name: Install Netlify CLI
        run: pnpm i -g netlify-cli

      # Create a new Netlify Site with a version specific subdomain
      # Deploy the output of @swisspost/design-system-documentation to the before created Netlify Site
      - name: Create & Deploy Netlify Site
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
        run: |
          netlify sites:create --filter @swisspost/design-system-documentation --account-slug oliverschuerch --name ${{ fromJSON(needs.collect-release-data.outputs.release-data).old.siteUrl }} --manual
          netlify deploy --filter @swisspost/design-system-documentation --build false --dir packages/documentation/storybook-static --prod

      - name: Update Changeset config.json
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const release = ${{ needs.collect-release-data.outputs.release-data }}

            const changesetConfigPath = './.changeset/config.json'
            const changesetConfig = JSON.parse(fs.readFileSync(changesetConfigPath, 'utf8'))
            fs.writeFileSync(changesetConfigPath, JSON.stringify({
              ...changesetConfig,
              baseBranch: release.branchName
            }, null, 2) + '\n')

      - name: Update Documentation netlify.config.json
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const release = ${{ needs.collect-release-data.outputs.release-data }}

            const netlifyState = JSON.parse(fs.readFileSync('./packages/documentation/.netlify/state.json', 'utf8'))
            fs.writeFileSync('./packages/documentation/netlify.config.json', JSON.stringify({
              ...netlifyState,
              siteUrl: `https://${release.old.siteUrl}.netlify.app`
            }, null, 2) + '\n')

      # Commit the changes to a new release/v* branch
      - name: Commit Changes and Push Release Branch
        uses: EndBug/add-and-commit@v9
        with:
          new_branch: ${{ fromJSON(needs.collect-release-data.outputs.release-data).branchName }}
          message: 'chore(setup): create "${{ fromJSON(needs.collect-release-data.outputs.release-data).branchName }}" branch'
          push: true

      - name: Create Summary
        id: summary
        uses: actions/github-script@v7
        env:
          RELEASE_DATA: ${{ needs.collect-release-data.outputs.release-data }}
        with:
          script: |
            const release = JSON.parse(process.env.RELEASE_DATA)

            return `# Release Branch
            - A new <code>${release.branchName}</code> Branch has been created.
            - The file <code>.changeset/config.json</code> (which holds the <code>baseBranch</code> property) has been updated on to the <code>${release.branchName}</code> Branch.
            - The file <code>documentation/netlify.config.json</code> (which holds the <code>siteId</code> and <code>siteUrl</code>) has been created on to the <code>${release.branchName}</code> Branch.
            - A new Netlify Page has been created and the build has been deployed to <code>https://${release.old.siteUrl}.netlify.app</code>.
            `

      - name: Output Summary
        run: echo -e ${{ steps.summary.outputs.result }} >> $GITHUB_STEP_SUMMARY

  # Only run this Job if:
  # - Workflow runs on the 'main' Branch
  # - Either a Release Branch or a Changeset Branch exists
  # - A non-Major Release was detected
  remove-release-branch:
    name: Remove release/v* Branch
    runs-on: ubuntu-latest
    needs: collect-release-data
    if: github.ref_name == 'main' && (needs.collect-release-data.outputs.release-branch-exists == 'true' || needs.collect-release-data.outputs.release-changeset-branch-exists == 'true') && fromJSON(needs.collect-release-data.outputs.release-data) != null && fromJSON(needs.collect-release-data.outputs.release-data).isMajor == false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Remove Changeset Branch
        if: needs.collect-release-data.outputs.release-changeset-branch-exists == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.SWISSPOSTDEVS_ACCESS_TOKEN }}
        run: git push origin --delete changeset-release/${{ fromJSON(needs.collect-release-data.outputs.release-data).branchName }}

      - name: Remove Release Branch
        if: needs.collect-release-data.outputs.release-branch-exists == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.SWISSPOSTDEVS_ACCESS_TOKEN }}
        run: git push origin --delete ${{ fromJSON(needs.collect-release-data.outputs.release-data).branchName }}

      - name: Create Summary
        id: summary
        uses: actions/github-script@v7
        env:
          RELEASE_DATA: ${{ needs.collect-release-data.outputs.release-data }}
        with:
          script: |
            const release = JSON.parse(process.env.RELEASE_DATA)

            return `# Release Branches
            There once was a Changeset with a Major update, which has been deleted within the latest updates, therefore the before created <code>${release.branchName}</code> and <code>changeset-release/${release.branchName}</code> Branches have been deleted.
            `

      - name: Output Summary
        run: echo -e ${{ steps.summary.outputs.result }} >> $GITHUB_STEP_SUMMARY
